// Licensed to Apache Software Foundation (ASF) under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Apache Software Foundation (ASF) licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: write.proto

package go_bench

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_struct "github.com/golang/protobuf/ptypes/struct"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Str struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Str) Reset()         { *m = Str{} }
func (m *Str) String() string { return proto.CompactTextString(m) }
func (*Str) ProtoMessage()    {}
func (*Str) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{0}
}
func (m *Str) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Str) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Str.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Str) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Str.Merge(m, src)
}
func (m *Str) XXX_Size() int {
	return m.Size()
}
func (m *Str) XXX_DiscardUnknown() {
	xxx_messageInfo_Str.DiscardUnknown(m)
}

var xxx_messageInfo_Str proto.InternalMessageInfo

func (m *Str) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Int struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Int) Reset()         { *m = Int{} }
func (m *Int) String() string { return proto.CompactTextString(m) }
func (*Int) ProtoMessage()    {}
func (*Int) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{1}
}
func (m *Int) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int.Merge(m, src)
}
func (m *Int) XXX_Size() int {
	return m.Size()
}
func (m *Int) XXX_DiscardUnknown() {
	xxx_messageInfo_Int.DiscardUnknown(m)
}

var xxx_messageInfo_Int proto.InternalMessageInfo

func (m *Int) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type StrArray struct {
	Value []string `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *StrArray) Reset()         { *m = StrArray{} }
func (m *StrArray) String() string { return proto.CompactTextString(m) }
func (*StrArray) ProtoMessage()    {}
func (*StrArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{2}
}
func (m *StrArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StrArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StrArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StrArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StrArray.Merge(m, src)
}
func (m *StrArray) XXX_Size() int {
	return m.Size()
}
func (m *StrArray) XXX_DiscardUnknown() {
	xxx_messageInfo_StrArray.DiscardUnknown(m)
}

var xxx_messageInfo_StrArray proto.InternalMessageInfo

func (m *StrArray) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

type IntArray struct {
	Value []int64 `protobuf:"varint,1,rep,packed,name=value,proto3" json:"value,omitempty"`
}

func (m *IntArray) Reset()         { *m = IntArray{} }
func (m *IntArray) String() string { return proto.CompactTextString(m) }
func (*IntArray) ProtoMessage()    {}
func (*IntArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{3}
}
func (m *IntArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntArray.Merge(m, src)
}
func (m *IntArray) XXX_Size() int {
	return m.Size()
}
func (m *IntArray) XXX_DiscardUnknown() {
	xxx_messageInfo_IntArray.DiscardUnknown(m)
}

var xxx_messageInfo_IntArray proto.InternalMessageInfo

func (m *IntArray) GetValue() []int64 {
	if m != nil {
		return m.Value
	}
	return nil
}

type Field struct {
	// Types that are valid to be assigned to ValueType:
	//	*Field_Null
	//	*Field_Str
	//	*Field_StrArray
	//	*Field_Int
	//	*Field_IntArray
	ValueType isField_ValueType `protobuf_oneof:"value_type"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{4}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

type isField_ValueType interface {
	isField_ValueType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Field_Null struct {
	Null _struct.NullValue `protobuf:"varint,1,opt,name=null,proto3,enum=google.protobuf.NullValue,oneof" json:"null,omitempty"`
}
type Field_Str struct {
	Str *Str `protobuf:"bytes,2,opt,name=str,proto3,oneof" json:"str,omitempty"`
}
type Field_StrArray struct {
	StrArray *StrArray `protobuf:"bytes,3,opt,name=str_array,json=strArray,proto3,oneof" json:"str_array,omitempty"`
}
type Field_Int struct {
	Int *Int `protobuf:"bytes,4,opt,name=int,proto3,oneof" json:"int,omitempty"`
}
type Field_IntArray struct {
	IntArray *IntArray `protobuf:"bytes,5,opt,name=int_array,json=intArray,proto3,oneof" json:"int_array,omitempty"`
}

func (*Field_Null) isField_ValueType()     {}
func (*Field_Str) isField_ValueType()      {}
func (*Field_StrArray) isField_ValueType() {}
func (*Field_Int) isField_ValueType()      {}
func (*Field_IntArray) isField_ValueType() {}

func (m *Field) GetValueType() isField_ValueType {
	if m != nil {
		return m.ValueType
	}
	return nil
}

func (m *Field) GetNull() _struct.NullValue {
	if x, ok := m.GetValueType().(*Field_Null); ok {
		return x.Null
	}
	return _struct.NullValue_NULL_VALUE
}

func (m *Field) GetStr() *Str {
	if x, ok := m.GetValueType().(*Field_Str); ok {
		return x.Str
	}
	return nil
}

func (m *Field) GetStrArray() *StrArray {
	if x, ok := m.GetValueType().(*Field_StrArray); ok {
		return x.StrArray
	}
	return nil
}

func (m *Field) GetInt() *Int {
	if x, ok := m.GetValueType().(*Field_Int); ok {
		return x.Int
	}
	return nil
}

func (m *Field) GetIntArray() *IntArray {
	if x, ok := m.GetValueType().(*Field_IntArray); ok {
		return x.IntArray
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Field) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Field_Null)(nil),
		(*Field_Str)(nil),
		(*Field_StrArray)(nil),
		(*Field_Int)(nil),
		(*Field_IntArray)(nil),
	}
}

type EntityValue struct {
	// entity_id could be span_id of a Span or segment_id of a Segment in the context of Trace
	EntityId string `protobuf:"bytes,1,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	// timestamp_nanoseconds is in the timeunit of nanoseconds. It represents
	// 1) either the start time of a Span/Segment,
	// 2) or the timestamp of a log
	TimestampNanoseconds uint64 `protobuf:"varint,2,opt,name=timestamp_nanoseconds,json=timestampNanoseconds,proto3" json:"timestamp_nanoseconds,omitempty"`
	// binary representation of segments, including tags, spans...
	DataBinary []byte `protobuf:"bytes,3,opt,name=data_binary,json=dataBinary,proto3" json:"data_binary,omitempty"`
	// support all of indexed fields in the fields.
	// Pair only has value, as the value of PairValue match with the key
	// by the index rules and index rule bindings of Metadata group.
	// indexed fields of multiple entities are compression in the fields.
	Fields []*Field `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields,omitempty"`
}

func (m *EntityValue) Reset()         { *m = EntityValue{} }
func (m *EntityValue) String() string { return proto.CompactTextString(m) }
func (*EntityValue) ProtoMessage()    {}
func (*EntityValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{5}
}
func (m *EntityValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntityValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntityValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityValue.Merge(m, src)
}
func (m *EntityValue) XXX_Size() int {
	return m.Size()
}
func (m *EntityValue) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityValue.DiscardUnknown(m)
}

var xxx_messageInfo_EntityValue proto.InternalMessageInfo

func (m *EntityValue) GetEntityId() string {
	if m != nil {
		return m.EntityId
	}
	return ""
}

func (m *EntityValue) GetTimestampNanoseconds() uint64 {
	if m != nil {
		return m.TimestampNanoseconds
	}
	return 0
}

func (m *EntityValue) GetDataBinary() []byte {
	if m != nil {
		return m.DataBinary
	}
	return nil
}

func (m *EntityValue) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Metadata struct {
	Group string `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{6}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Metadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type WriteEntity struct {
	// the mate_data is only required in the first write.
	MetaData *Metadata `protobuf:"bytes,1,opt,name=meta_data,json=metaData,proto3" json:"meta_data,omitempty"`
	// the entity is required.
	Entity *EntityValue `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`
}

func (m *WriteEntity) Reset()         { *m = WriteEntity{} }
func (m *WriteEntity) String() string { return proto.CompactTextString(m) }
func (*WriteEntity) ProtoMessage()    {}
func (*WriteEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_67966b2b12a73214, []int{7}
}
func (m *WriteEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteEntity.Merge(m, src)
}
func (m *WriteEntity) XXX_Size() int {
	return m.Size()
}
func (m *WriteEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteEntity.DiscardUnknown(m)
}

var xxx_messageInfo_WriteEntity proto.InternalMessageInfo

func (m *WriteEntity) GetMetaData() *Metadata {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *WriteEntity) GetEntity() *EntityValue {
	if m != nil {
		return m.Entity
	}
	return nil
}

func init() {
	proto.RegisterType((*Str)(nil), "banyandb.v1.Str")
	proto.RegisterType((*Int)(nil), "banyandb.v1.Int")
	proto.RegisterType((*StrArray)(nil), "banyandb.v1.StrArray")
	proto.RegisterType((*IntArray)(nil), "banyandb.v1.IntArray")
	proto.RegisterType((*Field)(nil), "banyandb.v1.Field")
	proto.RegisterType((*EntityValue)(nil), "banyandb.v1.EntityValue")
	proto.RegisterType((*Metadata)(nil), "banyandb.v1.Metadata")
	proto.RegisterType((*WriteEntity)(nil), "banyandb.v1.WriteEntity")
}

func init() { proto.RegisterFile("write.proto", fileDescriptor_67966b2b12a73214) }

var fileDescriptor_67966b2b12a73214 = []byte{
	// 543 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0xcf, 0x6a, 0xdb, 0x4e,
	0x10, 0x96, 0x7e, 0x72, 0x82, 0x3c, 0x0a, 0x3f, 0xca, 0x92, 0x80, 0x48, 0x8a, 0x6a, 0x4c, 0x0e,
	0xa1, 0x10, 0x29, 0x75, 0x72, 0xeb, 0x29, 0xa1, 0x2d, 0xf1, 0xa1, 0x39, 0x28, 0xd0, 0x42, 0x2f,
	0x62, 0x65, 0x6d, 0x94, 0x25, 0xd2, 0xae, 0x59, 0x8d, 0x12, 0x4c, 0x5f, 0xa2, 0x0f, 0xd2, 0x07,
	0xe9, 0x31, 0xc7, 0x1e, 0x8b, 0xfd, 0x20, 0x2d, 0xbb, 0x92, 0xfc, 0x27, 0xf8, 0x36, 0x33, 0xdf,
	0x37, 0xdf, 0xce, 0x7c, 0xb3, 0xe0, 0x3d, 0x29, 0x8e, 0x2c, 0x9c, 0x2a, 0x89, 0x92, 0x78, 0x29,
	0x15, 0x33, 0x2a, 0xb2, 0x34, 0x7c, 0x7c, 0x77, 0xb8, 0x9f, 0xcb, 0x5c, 0x9a, 0x7a, 0xa4, 0xa3,
	0x86, 0x72, 0xf8, 0x3a, 0x97, 0x32, 0x2f, 0x58, 0x64, 0xb2, 0xb4, 0xbe, 0x8b, 0x2a, 0x54, 0xf5,
	0x04, 0x1b, 0x74, 0x78, 0x04, 0xce, 0x2d, 0x2a, 0xb2, 0x0f, 0x3b, 0x8f, 0xb4, 0xa8, 0x99, 0x6f,
	0x0f, 0xec, 0x93, 0x7e, 0xdc, 0x24, 0x1a, 0x1c, 0x0b, 0xdc, 0x04, 0x9d, 0x0e, 0x1c, 0x80, 0x7b,
	0x8b, 0xea, 0x52, 0x29, 0x3a, 0x5b, 0x67, 0x38, 0xab, 0xf6, 0x01, 0xb8, 0x63, 0x81, 0x5b, 0x18,
	0x4b, 0x8d, 0xbf, 0x36, 0xec, 0x7c, 0xe2, 0xac, 0xc8, 0xc8, 0x19, 0xf4, 0x44, 0x5d, 0x14, 0xe6,
	0x89, 0xff, 0x47, 0x87, 0x61, 0x33, 0x74, 0xd8, 0x0d, 0x1d, 0xde, 0xd4, 0x45, 0xf1, 0x45, 0xf7,
	0x5c, 0x5b, 0xb1, 0x61, 0x92, 0x63, 0x70, 0x2a, 0x54, 0xfe, 0x7f, 0x03, 0xfb, 0xc4, 0x1b, 0xbd,
	0x0a, 0xd7, 0x8c, 0x08, 0x6f, 0x51, 0x5d, 0x5b, 0xb1, 0x86, 0xc9, 0x05, 0xf4, 0x2b, 0x54, 0x09,
	0xd5, 0x43, 0xf8, 0x8e, 0xe1, 0x1e, 0xbc, 0xe4, 0x9a, 0x09, 0xaf, 0xad, 0xd8, 0xad, 0xba, 0x7d,
	0x8e, 0xc1, 0xe1, 0x02, 0xfd, 0xde, 0x16, 0xed, 0xb1, 0x40, 0xad, 0xcd, 0x05, 0x6a, 0x6d, 0x2e,
	0xb0, 0xd5, 0xde, 0xd9, 0xa2, 0xdd, 0x6d, 0xaf, 0xb5, 0x79, 0x1b, 0x5f, 0xed, 0x01, 0x98, 0xe5,
	0x13, 0x9c, 0x4d, 0xd9, 0xf0, 0xa7, 0x0d, 0xde, 0x47, 0x81, 0x1c, 0x67, 0x66, 0x3b, 0x72, 0x04,
	0x7d, 0x66, 0xd2, 0x84, 0x67, 0xed, 0x31, 0xdc, 0xa6, 0x30, 0xce, 0xc8, 0x39, 0x1c, 0x20, 0x2f,
	0x59, 0x85, 0xb4, 0x9c, 0x26, 0x82, 0x0a, 0x59, 0xb1, 0x89, 0x14, 0x59, 0x65, 0x4c, 0xe8, 0xc5,
	0xfb, 0x4b, 0xf0, 0x66, 0x85, 0x91, 0x37, 0xe0, 0x65, 0x14, 0x69, 0x92, 0x72, 0x41, 0x55, 0xe3,
	0xc1, 0x5e, 0x0c, 0xba, 0x74, 0x65, 0x2a, 0xe4, 0x2d, 0xec, 0xde, 0xe9, 0x1b, 0x54, 0x7e, 0x6f,
	0xe0, 0x9c, 0x78, 0x23, 0xb2, 0xb1, 0x83, 0x39, 0x4f, 0xdc, 0x32, 0x86, 0x17, 0xe0, 0x7e, 0x66,
	0x48, 0x75, 0xb7, 0x3e, 0x69, 0xae, 0x64, 0x3d, 0xed, 0xfe, 0x8c, 0x49, 0x08, 0x81, 0x9e, 0xa0,
	0x25, 0x33, 0x23, 0xf5, 0x63, 0x13, 0x0f, 0x2b, 0xf0, 0xbe, 0xea, 0x4f, 0xdb, 0x2c, 0x4a, 0x46,
	0xd0, 0x2f, 0x19, 0xd2, 0x44, 0xab, 0x98, 0xe6, 0x97, 0xbe, 0x75, 0x4f, 0xc4, 0xae, 0xe6, 0x7d,
	0xd0, 0x8f, 0x9d, 0xc1, 0x6e, 0x63, 0x43, 0x7b, 0x70, 0x7f, 0xa3, 0x61, 0xcd, 0xc1, 0xb8, 0xe5,
	0x5d, 0x7d, 0xff, 0x35, 0x0f, 0xec, 0xe7, 0x79, 0x60, 0xff, 0x99, 0x07, 0xf6, 0x8f, 0x45, 0x60,
	0x3d, 0x2f, 0x02, 0xeb, 0xf7, 0x22, 0xb0, 0x20, 0x90, 0x2a, 0x0f, 0xe9, 0x94, 0x4e, 0xee, 0x59,
	0x58, 0x3d, 0xcc, 0x9e, 0x68, 0xf1, 0xc0, 0x45, 0xbe, 0x14, 0xfc, 0x76, 0x99, 0x73, 0xbc, 0xaf,
	0xd3, 0x70, 0x22, 0xcb, 0xa8, 0xa1, 0x45, 0x2b, 0xda, 0x69, 0x47, 0x8b, 0x52, 0x26, 0x26, 0xf7,
	0x25, 0x55, 0x0f, 0x51, 0x2e, 0x4f, 0x4d, 0xf2, 0x3e, 0x97, 0x89, 0x09, 0xd2, 0x5d, 0xf3, 0x71,
	0xcf, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x2b, 0xb0, 0xa4, 0x8b, 0xad, 0x03, 0x00, 0x00,
}

func (m *Str) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Str) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Str) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintWrite(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Int) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintWrite(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StrArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StrArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StrArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintWrite(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IntArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA2 := make([]byte, len(m.Value)*10)
		var j1 int
		for _, num1 := range m.Value {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintWrite(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueType != nil {
		{
			size := m.ValueType.Size()
			i -= size
			if _, err := m.ValueType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Field_Null) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field_Null) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintWrite(dAtA, i, uint64(m.Null))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Field_Str) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field_Str) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Str != nil {
		{
			size, err := m.Str.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWrite(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Field_StrArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field_StrArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StrArray != nil {
		{
			size, err := m.StrArray.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWrite(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Field_Int) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field_Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int != nil {
		{
			size, err := m.Int.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWrite(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Field_IntArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field_IntArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IntArray != nil {
		{
			size, err := m.IntArray.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWrite(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *EntityValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWrite(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DataBinary) > 0 {
		i -= len(m.DataBinary)
		copy(dAtA[i:], m.DataBinary)
		i = encodeVarintWrite(dAtA, i, uint64(len(m.DataBinary)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TimestampNanoseconds != 0 {
		i = encodeVarintWrite(dAtA, i, uint64(m.TimestampNanoseconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EntityId) > 0 {
		i -= len(m.EntityId)
		copy(dAtA[i:], m.EntityId)
		i = encodeVarintWrite(dAtA, i, uint64(len(m.EntityId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWrite(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintWrite(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteEntity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteEntity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entity != nil {
		{
			size, err := m.Entity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWrite(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MetaData != nil {
		{
			size, err := m.MetaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWrite(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintWrite(dAtA []byte, offset int, v uint64) int {
	offset -= sovWrite(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Str) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}

func (m *Int) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovWrite(uint64(m.Value))
	}
	return n
}

func (m *StrArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovWrite(uint64(l))
		}
	}
	return n
}

func (m *IntArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		l = 0
		for _, e := range m.Value {
			l += sovWrite(uint64(e))
		}
		n += 1 + sovWrite(uint64(l)) + l
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValueType != nil {
		n += m.ValueType.Size()
	}
	return n
}

func (m *Field_Null) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovWrite(uint64(m.Null))
	return n
}
func (m *Field_Str) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Str != nil {
		l = m.Str.Size()
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}
func (m *Field_StrArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StrArray != nil {
		l = m.StrArray.Size()
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}
func (m *Field_Int) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int != nil {
		l = m.Int.Size()
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}
func (m *Field_IntArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntArray != nil {
		l = m.IntArray.Size()
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}
func (m *EntityValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EntityId)
	if l > 0 {
		n += 1 + l + sovWrite(uint64(l))
	}
	if m.TimestampNanoseconds != 0 {
		n += 1 + sovWrite(uint64(m.TimestampNanoseconds))
	}
	l = len(m.DataBinary)
	if l > 0 {
		n += 1 + l + sovWrite(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovWrite(uint64(l))
		}
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovWrite(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}

func (m *WriteEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetaData != nil {
		l = m.MetaData.Size()
		n += 1 + l + sovWrite(uint64(l))
	}
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovWrite(uint64(l))
	}
	return n
}

func sovWrite(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWrite(x uint64) (n int) {
	return sovWrite(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Str) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Str: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Str: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StrArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWrite
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Value = append(m.Value, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWrite
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWrite
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWrite
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Value) == 0 {
					m.Value = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWrite
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Value = append(m.Value, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Null", wireType)
			}
			var v _struct.NullValue
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= _struct.NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValueType = &Field_Null{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Str{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ValueType = &Field_Str{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StrArray{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ValueType = &Field_StrArray{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Int{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ValueType = &Field_Int{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntArray{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ValueType = &Field_IntArray{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNanoseconds", wireType)
			}
			m.TimestampNanoseconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampNanoseconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataBinary", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataBinary = append(m.DataBinary[:0], dAtA[iNdEx:postIndex]...)
			if m.DataBinary == nil {
				m.DataBinary = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteEntity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaData == nil {
				m.MetaData = &Metadata{}
			}
			if err := m.MetaData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWrite
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWrite
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &EntityValue{}
			}
			if err := m.Entity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWrite(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWrite
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWrite(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWrite
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWrite
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWrite
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWrite
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWrite
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWrite        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWrite          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWrite = fmt.Errorf("proto: unexpected end of group")
)
